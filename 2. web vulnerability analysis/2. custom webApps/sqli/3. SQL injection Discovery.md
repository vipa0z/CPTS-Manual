
# testing escaping quotes
we first have to test whether the login form is vulnerable to SQL injection. To do that, we will try to add one of the below payloads after our username and see if it causes any errors or changes how the page behaves:
![](Pasted%20image%2020250421175624.png)
```sql
SELECT * FROM logins WHERE username='rtardx21'--' AND password = 'something';
```

# INJECTION TYPES
![](types_of_sqli.jpg)
## OR Injection

We would need the query always to return `true`, regardless of the username and password entered, to bypass the authentication. To do this, we can abuse the `OR` operator in our SQL injection.

 the MySQL documentation for [operation precedence](https://dev.mysql.com/doc/refman/8.0/en/operator-precedence.html) states that the `AND` operator would be evaluated before the `OR` operator. This means that if there is at least one `TRUE` condition in the entire query along with an `OR` operator, the entire query will evaluate to `TRUE` since the `OR` operator returns `TRUE` if one of its operands is `TRUE`.

An example of a condition that will always return `true` is `'1'='1'`. However, to keep the SQL query working and keep an even number of quotes, instead of using ('1'='1'), w

So, if we inject the below condition and have an `OR` operator between it and the original condition, it should always return `true`:

The final query should be as follow:
```sql
SELECT * FROM logins WHERE username='admin' or '1'='1' AND password = 'something';
```
- If username is `admin`  
    `OR`
- If `1=1` return `true` 'which always returns `true`'  
    `AND`
- If password is `something`

```SQL
admin' 0R '1'=1'--AND PASSWORD=XAEAEAEA
```
```sql
admin' or '1'='1
```